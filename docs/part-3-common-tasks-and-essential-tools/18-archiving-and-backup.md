# 18. 存档和备份

计算机系统管理员的一个主要任务之一，是保持系统的数据安全。完成这项任务的一个途径是定时执行系统文件的备份。即便你不是一个系统管理员，在设备之间制作拷贝和移动巨大的文件集，也是很有用的。

本章中，我们将看到几个用来管理文件集的常用程序。它们是文件压缩程序：

- `gzip` 压缩或扩展文件
- `bzip2` 块排序文件压缩器

还有存档程序：

- `tar` 磁带存档工具
- `zip` 大包和压缩文件

和文件同步程序：

- `rsync` 远程文件和目录同步

## 压缩文件

在整个计算机历史中，人们一直在努力将最多的数据放入最小的可用空间中，无论该空间是内存、存储设备还是网络带宽。今天，许多我们认为理所当然的数据服务，如移动电话服务、高清电视、宽带互联网，都归功于有效的<u>数据压缩</u>（*data compression*）技术。

数据压缩是一个移除<u>冗余</u>（*redundancy*）数据的进程。来考虑一个虚拟场景。假设我们有一个全黑的图片文件，尺寸是 `100*100` 像素。就数据存储而言（假设是 24 位，或者每像素 3 字节），则该图片将占据 30,000 字节的存储空间（`100*100*3 = 30,000`）。

一个单一颜色的图像全都是冗余数据。如果我们聪明点，可以用一种方法编码数据，以便简单地描述「有 10,000 个黑像素块」这个事实。所以，取代存储包含有 30,000 个零的数据块（黑色在图像文件中通常被表述为 0），我们可以压缩数据到 10,000，跟随一个零，来表述我们的数据。这种数据压缩方案名为游程编码或行程长度编码（*run-length encoding*），是一种最初级的压缩技术。当今的技术已经是更高级更复杂了，但是基本目标是一样的——去除冗余数据。

<u>压缩算法</u>（*compression algorithms*）（以数学技术实现压缩），有两个普通的类别。

- 无损（*lossless*）：无损压缩保存所有包含的数据为原始状态。这意味着当一个文件从压缩版本中恢复的时候，其所恢复的文件和原始未压缩文件一模一样。
- 有损（*lossy*）：有损压缩，在另一面，当执行压缩时移除了数据，以允许应用更多的压缩。当恢复一个有损文件时，不会符合原始版本，相反，它是一个近似值。有损压缩的示例，是 JPEG 图像和 MP3 音乐。

在我们的讨论中，我们将专门研究无损压缩，因为计算机上的大多数数据都不能容忍任何数据丢失。

### gzip

`gzip` 程序用来压缩一个或多个文件。当执行后，会用压缩版本替换原始文件。相应的 `gunzip` 程序则用来恢复压缩文件为原始文件。这里是个例子：

```bash
[me@linuxbox ~]$ ls -l /etc > foo.txt
[me@linuxbox ~]$ ls -l foo.*
-rw-r--r-- 1 me    me    15738    2018-10-14 07:15 foo.txt
[me@linuxbox ~]$ gzip foo.txt
[me@linuxbox ~]$ ls -l foo.*
-rw-r--r-- 1 me    me    3230    2018-10-14 07:15 foo.txt.gz
[me@linuxbox ~]$ gunzip foo.txt
[me@linuxbox ~]$ ls -l foo.*
-rw-r--r-- 1 me    me    15738    2018-10-14 07:15 foo.txt
```

本例中，我们用一个目录中的文件列表创建了一个文件，名为 `foo.txt`。然后运行 `gzip`，它用一个压缩版本 `foo.txt.gz` 替换了原始文件。在目录中列出 `foo.*`，我们看到原始文件已经被压缩版本取代，而压缩文件大约只有原始文件五分之一的尺寸。还可以看到压缩文件具有相同的权限和时间戳。

接下来，我们运行 `gunzip` 程序以解压缩文件。然后，我们可以看到压缩版本的文件被原始文件所替换，权限和时间戳再次保留了下来。

`gzip` 具有许多选项，如表 18-1 所描述。

表 18-1：gzip 选项

| 选项      | 长选项                             | 描述                                                         |
| --------- | ---------------------------------- | ------------------------------------------------------------ |
| `-c`      | `--stdout`<br />`--to-stdout`      | 输出到标准输出，保留原始文件。                               |
| `-d`      | `--decompress`<br />`--uncompress` | 解压。功效同 `gunzip`。                                      |
| `-f`      | `--force`                          | 强行压缩，即使原始文件的压缩版本已经存在。                   |
| `-h`      | `--help`                           | 显示帮助信息。                                               |
| `-l`      | `--list`                           | 列出每个压缩文件的压缩统计数据。                             |
| `-r`      | `--recursive`                      | 如果命令行上的一个或多个参数是目录，则递归压缩其中包含的文件。 |
| `-t`      | `--test`                           | 测试一个压缩文件的完整性。                                   |
| `-v`      | `--verbose`                        | 压缩时显示详细信息。                                         |
| `-number` |                                    | 设定压缩量。*number* 是一个从 1 （最快，最少的压缩量）到 9 （最慢，最多的压缩量）的整数。数字还可以用 `---fast` 和 `--best` 来表述。默认值为 6。 |

回到更早的例子。

```bash
[me@linuxbox ~]$ gzip foo.txt
[me@linuxbox ~]$ gzip -tv foo.txt.gz
foo.txt.gz:   OK
[me@linuxbox ~]$ gzip -d foo.txt.gz
```

这里，我们用一个压缩版本的 `foo.txt.gz` 替换了文件 `foo.txt`。然后用 `-t` 和 `-v` 选项测试了压缩版本的完整性。最后，解压文件为原始形式。

`gzip` 还可以通过标准输入和输出，用起来更有趣。

```bash
[me@linuxbox ~]$ ls -l /etc | gzip > foo.txt.gz
```

该命令创建了一个目录列表的压缩版本。

解压 `gzip` 文件的 `gunzip` 程序，假设压缩文件名以 `.gz` 扩展名结尾，所以就不必指定文件的扩展名，只要指定的名称与现有的未压缩文件不冲突即可。

```bash
[me@linuxbox ~]$ gunzip foo.txt
```

如果仅仅是要查看压缩的文本文件的内容，可以这样做：

```bash
[me@linuxbox ~]$ gunzip -c foo.txt | less
```

可替换的，由 `gzip` 提供的一个程序，名为 `zcat`，等价于带 `-c` 选项的 `gunzip` 程序。它用起来像 `cat` 命令一样，用在 `gzip` 压缩文件上。

```bash
[me@linuxbox ~]$ zcat foo.txt.gz | less
```

> **提示：**还有一个 `zless` 程序。执行和上面这个管道命令一样的功能。

### bzip2

`bzip2` 程序由 Julian Seward 编写，与 `gzip` 类似，但是使用不同的压缩算法，以牺牲压缩速度来得到更高级别的压缩。大多数情况下，其工作方式和 `gzip` 一样。由 `bzip2` 压缩的文件得到 `.bz2` 的扩展名。

```bash
[me@linuxbox ~]$ ls -l /etc > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-r--r-- 1 me    me    15738 2018-10-17 13:51 foo.txt
[me@linuxbox ~]$ bzip2 foo.txt
[me@linuxbox ~]$ ls -l foo.txt.bz2
-rw-r--r-- 1 me    me     2792 2018-10-17 13:51 foo.txt.bz2
[me@linuxbox ~]$ bunzip2 foo.txt.bz2
```

可以看到，`bzip2` 的用法和 `gzip` 一样。所有在 `gzip` 中讨论过的的选项（除了 `-r`）都可以用在 `bzip2` 中。但请注意，压缩级别选项（`-number`）与 `bzip2` 的含义有些不同。`bzip2` 附带了 `bunzip2` 和 `bzcat` 来解压缩文件。

`bzip2` 还带来了 `bzip2recover` 程序，可以尝试恢复那些损坏的 `.bz2` 文件。

> **不要强制压缩**
>
> 我偶尔看到人民尝试压缩一个已经由有效压缩算法压缩过的文件，如这样的：
>
> **`gzip picture.jpg`**
>
> 不要这么做。你就是在浪费时间和磁盘空间！如果你压缩一个已经压缩过的文件，通常情况下你会得到一个更大的文件。因为所有压缩技术都涉及一些添加到文件中以描述压缩的开销。如果你试图压缩一个已经没有冗余信息的文件，压缩行为通常不会导致任何节省以抵消额外的开销。

## 存档文件

常见的文件管理任务通常会把压缩和<u>存档</u>（*archiving*）联系在一起。存档是一个将许多文件收集起来捆绑在一个单独的大文件中的进程。存档通常作为系统备份的一部分，也用在将老旧数据从系统中移动到某些长期存储设备中时。

### tar

在类 Unix 软件世界中，`tar` 程序是一款经典的存档工具。它得名自 *tape archive* 的缩写，揭示其根源是一款制作磁带备份的工具。它仍然用于传统的任务，同时也适用于其它存储设备。我们经常可以看到以 `tar` 或 `tgz` 的扩展名结尾的文件，分别指示其为一个「普通」的 tar 存档文件或一个 gzip 压缩存档。tar 存档可以包含一组单独的文件，一个或多个目录层次结构，或两者的混合。命令句法如下：

```bash
tar mode[options] pathname...
```

这里，*mode* 是下表所列的操作模式之一（表 18-2 仅列出部分，可以查看 `tar` 手册页获取完整列表）。

表 18-2：tar 模式

| 模式 | 描述                               |
| ---- | ---------------------------------- |
| `c`  | 从一个文件或目录列表创建一个存档。 |
| `x`  | 释放一个存档。                     |
| `r`  | 附加指定路径名到一个存档的末尾。   |
| `t`  | 列出一个存档的内容。               |

`tar` 使用了一种稍微有点奇怪的方法来表示选项，所以我们需要一些例子来展示其如何工作。首先，重建一个游戏场，如上章所述。

```bash
[me@linuxbox ~]$ mkdir -p playground/dir-{001..100}
[me@linuxbox ~]$ touch playground/dir-{001..100}/file-{A..Z}
```

其次，创建一个整个游戏场的 tar 存档。

```bash
[me@linuxbox ~]$ tar cf playground.tar playground
```

该命令创建了一个名为 `playground.tar` 的 tar 存档，包含了整个游戏场目录层次。可以看到模式和 `f` 选项，

### zip



## 同步文件和目录



### 使用 rsync 跨越网络



## 总结



## 扩展阅读

