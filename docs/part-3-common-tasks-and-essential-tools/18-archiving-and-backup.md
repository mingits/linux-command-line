# 18. 存档和备份

计算机系统管理员的一个主要任务之一，是保持系统的数据安全。完成这项任务的一个途径是定时执行系统文件的备份。即便你不是一个系统管理员，在设备之间制作拷贝和移动巨大的文件集，也是很有用的。

本章中，我们将看到几个用来管理文件集的常用程序。它们是文件压缩程序：

- `gzip` 压缩或扩展文件
- `bzip2` 块排序文件压缩器

还有存档程序：

- `tar` 磁带存档工具
- `zip` 大包和压缩文件

和文件同步程序：

- `rsync` 远程文件和目录同步

## 压缩文件

在整个计算机历史中，人们一直在努力将最多的数据放入最小的可用空间中，无论该空间是内存、存储设备还是网络带宽。今天，许多我们认为理所当然的数据服务，如移动电话服务、高清电视、宽带互联网，都归功于有效的<u>数据压缩</u>（*data compression*）技术。

数据压缩是一个移除<u>冗余</u>（*redundancy*）数据的进程。来考虑一个虚拟场景。假设我们有一个全黑的图片文件，尺寸是 `100*100` 像素。就数据存储而言（假设是 24 位，或者每像素 3 字节），则该图片将占据 30,000 字节的存储空间（`100*100*3 = 30,000`）。

一个单一颜色的图像全都是冗余数据。如果我们聪明点，可以用一种方法编码数据，以便简单地描述「有 10,000 个黑像素块」这个事实。所以，取代存储包含有 30,000 个零的数据块（黑色在图像文件中通常被表述为 0），我们可以压缩数据到 10,000，跟随一个零，来表述我们的数据。这种数据压缩方案名为游程编码或行程长度编码（*run-length encoding*），是一种最初级的压缩技术。当今的技术已经是更高级更复杂了，但是基本目标是一样的——去除冗余数据。

<u>压缩算法</u>（*compression algorithms*）（以数学技术实现压缩），有两个普通的类别。

- 无损（*lossless*）：无损压缩保存所有包含的数据为原始状态。这意味着当一个文件从压缩版本中恢复的时候，其所恢复的文件和原始未压缩文件一模一样。
- 有损（*lossy*）：有损压缩，在另一面，当执行压缩时移除了数据，以允许应用更多的压缩。当恢复一个有损文件时，不会符合原始版本，相反，它是一个近似值。有损压缩的示例，是 JPEG 图像和 MP3 音乐。

在我们的讨论中，我们将专门研究无损压缩，因为计算机上的大多数数据都不能容忍任何数据丢失。

### gzip

`gzip` 程序用来压缩一个或多个文件。当执行后，会用压缩版本替换原始文件。相应的 `gunzip` 程序则用来恢复压缩文件为原始文件。这里是个例子：

```bash
[me@linuxbox ~]$ ls -l /etc > foo.txt
[me@linuxbox ~]$ ls -l foo.*
-rw-r--r-- 1 me    me    15738    2018-10-14 07:15 foo.txt
[me@linuxbox ~]$ gzip foo.txt
[me@linuxbox ~]$ ls -l foo.*
-rw-r--r-- 1 me    me    3230    2018-10-14 07:15 foo.txt.gz
[me@linuxbox ~]$ gunzip foo.txt
[me@linuxbox ~]$ ls -l foo.*
-rw-r--r-- 1 me    me    15738    2018-10-14 07:15 foo.txt
```

本例中，我们用一个目录中的文件列表创建了一个文件，名为 `foo.txt`。然后运行 `gzip`，它用一个压缩版本 `foo.txt.gz` 替换了原始文件。在目录中列出 `foo.*`，我们看到原始文件已经被压缩版本取代，而压缩文件大约只有原始文件五分之一的尺寸。还可以看到压缩文件具有相同的权限和时间戳。

接下来，我们运行 `gunzip` 程序以解压缩文件。然后，我们可以看到压缩版本的文件被原始文件所替换，权限和时间戳再次保留了下来。

`gzip` 具有许多选项，如表 18-1 所描述。

表 18-1：gzip 选项

| 选项      | 长选项                             | 描述                                                         |
| --------- | ---------------------------------- | ------------------------------------------------------------ |
| `-c`      | `--stdout`<br />`--to-stdout`      | 输出到标准输出，保留原始文件。                               |
| `-d`      | `--decompress`<br />`--uncompress` | 解压。功效同 `gunzip`。                                      |
| `-f`      | `--force`                          | 强行压缩，即使原始文件的压缩版本已经存在。                   |
| `-h`      | `--help`                           | 显示帮助信息。                                               |
| `-l`      | `--list`                           | 列出每个压缩文件的压缩统计数据。                             |
| `-r`      | `--recursive`                      | 如果命令行上的一个或多个参数是目录，则递归压缩其中包含的文件。 |
| `-t`      | `--test`                           | 测试一个压缩文件的完整性。                                   |
| `-v`      | `--verbose`                        | 压缩时显示详细信息。                                         |
| `-number` |                                    | 设定压缩量。*number* 是一个从 1 （最快，最少的压缩量）到 9 （最慢，最多的压缩量）的整数。数字还可以用 `---fast` 和 `--best` 来表述。默认值为 6。 |

回到更早的例子。

```bash
[me@linuxbox ~]$ gzip foo.txt
[me@linuxbox ~]$ gzip -tv foo.txt.gz
foo.txt.gz:   OK
[me@linuxbox ~]$ gzip -d foo.txt.gz
```

这里，我们用一个压缩版本的 `foo.txt.gz` 替换了文件 `foo.txt`。然后用 `-t` 和 `-v` 选项测试了压缩版本的完整性。最后，解压文件为原始形式。

`gzip` 还可以通过标准输入和输出，用起来更有趣。

```bash
[me@linuxbox ~]$ ls -l /etc | gzip > foo.txt.gz
```

该命令创建了一个目录列表的压缩版本。

解压 `gzip` 文件的 `gunzip` 程序，假设压缩文件名以 `.gz` 扩展名结尾，所以就不必指定文件的扩展名，只要指定的名称与现有的未压缩文件不冲突即可。

```bash
[me@linuxbox ~]$ gunzip foo.txt
```

如果仅仅是要查看压缩的文本文件的内容，可以这样做：

```bash
[me@linuxbox ~]$ gunzip -c foo.txt | less
```

可替换的，由 `gzip` 提供的一个程序，名为 `zcat`，等价于带 `-c` 选项的 `gunzip` 程序。它用起来像 `cat` 命令一样，用在 `gzip` 压缩文件上。

```bash
[me@linuxbox ~]$ zcat foo.txt.gz | less
```

> **提示：**还有一个 `zless` 程序。执行和上面这个管道命令一样的功能。

### bzip2



## 存档文件



### tar



### zip



## 同步文件和目录



### 使用 rsync 跨越网络



## 总结



## 扩展阅读

