# 18. 存档和备份

计算机系统管理员的一个主要任务之一，是保持系统的数据安全。完成这项任务的一个途径是定时执行系统文件的备份。即便你不是一个系统管理员，在设备之间制作拷贝和移动巨大的文件集，也是很有用的。

本章中，我们将看到几个用来管理文件集的常用程序。它们是文件压缩程序：

- `gzip` 压缩或扩展文件
- `bzip2` 块排序文件压缩器

还有存档程序：

- `tar` 磁带存档工具
- `zip` 大包和压缩文件

和文件同步程序：

- `rsync` 远程文件和目录同步

## 压缩文件

在整个计算机历史中，人们一直在努力将最多的数据放入最小的可用空间中，无论该空间是内存、存储设备还是网络带宽。今天，许多我们认为理所当然的数据服务，如移动电话服务、高清电视、宽带互联网，都归功于有效的<u>数据压缩</u>（*data compression*）技术。

数据压缩是一个移除<u>冗余</u>（*redundancy*）数据的进程。来考虑一个虚拟场景。假设我们有一个全黑的图片文件，尺寸是 `100*100` 像素。就数据存储而言（假设是 24 位，或者每像素 3 字节），则该图片将占据 30,000 字节的存储空间（`100*100*3 = 30,000`）。

一个单一颜色的图像全都是冗余数据。如果我们聪明点，可以用一种方法编码数据，以便简单地描述「有 10,000 个黑像素块」这个事实。所以，取代存储包含有 30,000 个零的数据块（黑色在图像文件中通常被表述为 0），我们可以压缩数据到 10,000，跟随一个零，来表述我们的数据。这种数据压缩方案名为游程编码或行程长度编码（*run-length encoding*），是一种最初级的压缩技术。当今的技术已经是更高级更复杂了，但是基本目标是一样的——去除冗余数据。

<u>压缩算法</u>（*compression algorithms*）（以数学技术实现压缩），有两个普通的类别。

- 无损（*lossless*）：无损压缩保存所有包含的数据为原始状态。这意味着当一个文件从压缩版本中恢复的时候，其所恢复的文件和原始未压缩文件一模一样。
- 有损（*lossy*）：有损压缩，在另一面，当执行压缩时移除了数据，以允许应用更多的压缩。当恢复一个有损文件时，不会符合原始版本，相反，它是一个近似值。有损压缩的示例，是 JPEG 图像和 MP3 音乐。

在我们的讨论中，我们将专门研究无损压缩，因为计算机上的大多数数据都不能容忍任何数据丢失。

### gzip

`gzip` 程序用来压缩一个或多个文件。当执行后，会用压缩版本替换原始文件。相应的 `gunzip` 程序则用来恢复压缩文件为原始文件。这里是个例子：

```bash
[me@linuxbox ~]$ ls -l /etc > foo.txt
[me@linuxbox ~]$ ls -l foo.*
-rw-r--r-- 1 me    me    15738    2018-10-14 07:15 foo.txt
[me@linuxbox ~]$ gzip foo.txt
[me@linuxbox ~]$ ls -l foo.*
-rw-r--r-- 1 me    me    3230    2018-10-14 07:15 foo.txt.gz
[me@linuxbox ~]$ gunzip foo.txt
[me@linuxbox ~]$ ls -l foo.*
-rw-r--r-- 1 me    me    15738    2018-10-14 07:15 foo.txt
```

本例中，我们用一个目录中的文件列表创建了一个文件，名为 `foo.txt`。然后运行 `gzip`，它用一个压缩版本 `foo.txt.gz` 替换了原始文件。在目录中列出 `foo.*`，我们看到原始文件已经被压缩版本取代，而压缩文件大约只有原始文件五分之一的尺寸。还可以看到压缩文件具有相同的权限和时间戳。

接下来，我们运行 `gunzip` 程序以解压缩文件。然后，我们可以看到压缩版本的文件被原始文件所替换，权限和时间戳再次保留了下来。

`gzip` 具有许多选项，如表 18-1 所描述。

表 18-1：gzip 选项

| 选项      | 长选项                             | 描述                                                         |
| --------- | ---------------------------------- | ------------------------------------------------------------ |
| `-c`      | `--stdout`<br />`--to-stdout`      | 输出到标准输出，保留原始文件。                               |
| `-d`      | `--decompress`<br />`--uncompress` | 解压。功效同 `gunzip`。                                      |
| `-f`      | `--force`                          | 强行压缩，即使原始文件的压缩版本已经存在。                   |
| `-h`      | `--help`                           | 显示帮助信息。                                               |
| `-l`      | `--list`                           | 列出每个压缩文件的压缩统计数据。                             |
| `-r`      | `--recursive`                      | 如果命令行上的一个或多个参数是目录，则递归压缩其中包含的文件。 |
| `-t`      | `--test`                           | 测试一个压缩文件的完整性。                                   |
| `-v`      | `--verbose`                        | 压缩时显示详细信息。                                         |
| `-number` |                                    | 设定压缩量。*number* 是一个从 1 （最快，最少的压缩量）到 9 （最慢，最多的压缩量）的整数。数字还可以用 `---fast` 和 `--best` 来表述。默认值为 6。 |

回到更早的例子。

```bash
[me@linuxbox ~]$ gzip foo.txt
[me@linuxbox ~]$ gzip -tv foo.txt.gz
foo.txt.gz:   OK
[me@linuxbox ~]$ gzip -d foo.txt.gz
```

这里，我们用一个压缩版本的 `foo.txt.gz` 替换了文件 `foo.txt`。然后用 `-t` 和 `-v` 选项测试了压缩版本的完整性。最后，解压文件为原始形式。

`gzip` 还可以通过标准输入和输出，用起来更有趣。

```bash
[me@linuxbox ~]$ ls -l /etc | gzip > foo.txt.gz
```

该命令创建了一个目录列表的压缩版本。

解压 `gzip` 文件的 `gunzip` 程序，假设压缩文件名以 `.gz` 扩展名结尾，所以就不必指定文件的扩展名，只要指定的名称与现有的未压缩文件不冲突即可。

```bash
[me@linuxbox ~]$ gunzip foo.txt
```

如果仅仅是要查看压缩的文本文件的内容，可以这样做：

```bash
[me@linuxbox ~]$ gunzip -c foo.txt | less
```

可替换的，由 `gzip` 提供的一个程序，名为 `zcat`，等价于带 `-c` 选项的 `gunzip` 程序。它用起来像 `cat` 命令一样，用在 `gzip` 压缩文件上。

```bash
[me@linuxbox ~]$ zcat foo.txt.gz | less
```

> **提示：**还有一个 `zless` 程序。执行和上面这个管道命令一样的功能。

### bzip2

`bzip2` 程序由 Julian Seward 编写，与 `gzip` 类似，但是使用不同的压缩算法，以牺牲压缩速度来得到更高级别的压缩。大多数情况下，其工作方式和 `gzip` 一样。由 `bzip2` 压缩的文件得到 `.bz2` 的扩展名。

```bash
[me@linuxbox ~]$ ls -l /etc > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-r--r-- 1 me    me    15738 2018-10-17 13:51 foo.txt
[me@linuxbox ~]$ bzip2 foo.txt
[me@linuxbox ~]$ ls -l foo.txt.bz2
-rw-r--r-- 1 me    me     2792 2018-10-17 13:51 foo.txt.bz2
[me@linuxbox ~]$ bunzip2 foo.txt.bz2
```

可以看到，`bzip2` 的用法和 `gzip` 一样。所有在 `gzip` 中讨论过的的选项（除了 `-r`）都可以用在 `bzip2` 中。但请注意，压缩级别选项（`-number`）与 `bzip2` 的含义有些不同。`bzip2` 附带了 `bunzip2` 和 `bzcat` 来解压缩文件。

`bzip2` 还带来了 `bzip2recover` 程序，可以尝试恢复那些损坏的 `.bz2` 文件。

> **不要强制压缩**
>
> 我偶尔看到人民尝试压缩一个已经由有效压缩算法压缩过的文件，如这样的：
>
> **`gzip picture.jpg`**
>
> 不要这么做。你就是在浪费时间和磁盘空间！如果你压缩一个已经压缩过的文件，通常情况下你会得到一个更大的文件。因为所有压缩技术都涉及一些添加到文件中以描述压缩的开销。如果你试图压缩一个已经没有冗余信息的文件，压缩行为通常不会导致任何节省以抵消额外的开销。

## 存档文件

常见的文件管理任务通常会把压缩和<u>存档</u>（*archiving*）联系在一起。存档是一个将许多文件收集起来捆绑在一个单独的大文件中的进程。存档通常作为系统备份的一部分，也用在将老旧数据从系统中移动到某些长期存储设备中时。

### tar

在类 Unix 软件世界中，`tar` 程序是一款经典的存档工具。它得名自 *tape archive* 的缩写，揭示其根源是一款制作磁带备份的工具。它仍然用于传统的任务，同时也适用于其它存储设备。我们经常可以看到以 `tar` 或 `tgz` 的扩展名结尾的文件，分别指示其为一个「普通」的 tar 存档文件或一个 gzip 压缩存档。tar 存档可以包含一组单独的文件，一个或多个目录层次结构，或两者的混合。命令句法如下：

```bash
tar mode[options] pathname...
```

这里，*mode* 是下表所列的操作模式之一（表 18-2 仅列出部分，可以查看 `tar` 手册页获取完整列表）。

表 18-2：tar 模式

| 模式 | 描述                               |
| ---- | ---------------------------------- |
| `c`  | 从一个文件或目录列表创建一个存档。 |
| `x`  | 释放一个存档。                     |
| `r`  | 附加指定路径名到一个存档的末尾。   |
| `t`  | 列出一个存档的内容。               |

`tar` 使用了一种稍微有点奇怪的方法来表示选项，所以我们需要一些例子来展示其如何工作。首先，重建一个游戏场，如上章所述。

```bash
[me@linuxbox ~]$ mkdir -p playground/dir-{001..100}
[me@linuxbox ~]$ touch playground/dir-{001..100}/file-{A..Z}
```

其次，创建一个整个游戏场的 tar 存档。

```bash
[me@linuxbox ~]$ tar cf playground.tar playground
```

该命令创建了一个名为 `playground.tar` 的 tar 存档，包含了整个游戏场目录层次。可以看到模式（`c`）和用来指定 tar 存档文件名的 `f` 选项，二者可以连接在一起，也不需要一个前置短横（`-`）。记住，必须先指定模式，模式总是在其他选项之前。

要列出存档内容，可以这么做：

```bash
[me@linuxbox ~]$ tar tf playground.tar
```

要看更详细的清单，可以加个 `v` 选项（verbose）。

```bash
[me@linuxbox ~]$ tar tvf playground.tar
```

现在，让我们解压游戏场到一个新处所。来创建一个新的目录，`foo`，切换到该目录然后解压 tar 存档。

```bash
[me@linuxbox ~]$ mkdir foo
[me@linuxbox ~]$ cd foo
[me@linuxbox foo]$ tar xf ../playground.tar
[me@linuxbox foo]$ ls
playground
```

如果我们检查 `~/foo/playground` 的内容，可以看到存档已经得以成功地安置，创建了一个原始文件的精确的副本。这里有个警告。除非我们正以超级用户的身份在操作，否则从存档中解压的文件和目录的属主就会改成执行恢复操作的用户，而非原始的属主。

另一个有趣的 tar 的行为，是其处理存档中的路径名。默认的路径名是相对路径而非绝对路径。tar 仅仅简单地在创建存档时，将前置的 `/` 从路径名中删掉。来演示一下，首先将重建存档，这次则指定了绝对路径。

```bash
[me@linuxbox foo]$ cd
[me@linuxbox ~]$ tar cf playground2.tar ~/playground
```

记住 `~/playground` 会在我们按下 `Enter` 键后扩展为 `/home/me/playground`，所以我们会得到在演示中得到一个绝对路径。接下来，我们来解压这个存档，看看会发生什么。

```bash
[me@linuxbox ~] cd foo
[me@linuxbox foo] tar xf ../playground2.tar
[me@linuxbox foo]$ ls
home playground
[me@linuxbox foo]$ ls home
me
[me@linuxbox foo]$ ls home/me
playground
```

这里我们可以看到，当我们解压第二个存档时，它在相对于我们的当前工作目录 `~/foo` 而不是相对于根目录，重新创建了 `home/me/playground` 目录，就像和绝对路径一样。这种工作方式可能看起来很奇怪，但是实际上这种方式会更有用，因为这允许我们解压存档到任意位置，而非被强制解压到它们的原始位置。用包含详细信息选项 `v` 来重复一下这个练习，会更清楚地了解发生了什么。

来考虑一个假象的不过也是实际的 tar 行为。想象我们想要从一个系统中复制家目录及其内容到另一个系统中，我们有一个大容量 USB 硬盘可以用来传输。在现代 Linux 系统中，该驱动器是「自动」被加载到 `/media` 目录中的。同时，假设在加载时，该磁盘的卷标是 `BigDisk`。要制作 tar 存档的话，我们可以这么做：

```bash
[me@linuxbox ~]$ sudo tar cf /media/BigDisk/home.tar /home
```

在写入 tar 文件之后，卸载驱动器，并加载到第二台计算机中。U 盘有又一次被加载为 `/media/BigDisk`。要解压这个存档，可以这么做：

```bash
[me@linuxbox2 ~]$ cd /
[me@linuxbox2 /]$ sudo tar xf /media/BigDisk/home.tar
```

这里重要的是，我们首先要切换到 `/`，以便解压是相对于根目录的，因为存档中的所有路径都是相对的。

当解压一个存档时，可以限制哪些文件从存档中解压出来。例如，假设我们想从存档中解压出单个文件，可以这样去完成：

```bash
tar xf archive.tar pathname
```

通过添加尾随的 `pathname`，tar 就会仅仅恢复那个指定的文件。还可以指定多个路径名。注意，路径名必须是存储在存档中完整准确的相对路径名。当指定路径名时，通配符是不受支持的，然而，GNU 版本的 tar （大多数常见 Linux 发行版中的版本）通过 `--wildcards` 选项可以支持通配符。这里可以用之前的游戏场文件举例如下：

```bash
[me@linuxbox ~]$ cd foo
[me@linuxbox foo]$ tar xf ../playground2.tar --wildcards 'home/me/playground/dir-*/file-A'
```

这条命令会仅仅解压匹配指定路径名中包含通配符 `dir-*` 的文件。

tar 经常被用来和 `find` 结合使用来制作存档。在下例中，将用到 `find` 来产生一个文件集，并包含到一个存档中。

```bash
[me@linuxbox ~]$ find playground -name 'file-A' -exec tar rf playground.tar '{}' '+'
```



### zip



## 同步文件和目录



### 使用 rsync 跨越网络



## 总结



## 扩展阅读

